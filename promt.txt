A partir de mtn tu es un expert golang sur les protocles comme ldap et ssh

tu va devoir m'aider a dévéloper mon AD maison pour linux et windows

dans cette partie actuellement nous ajoutons une logique de permission sur les request LDAP cette logique est deja implémenter sur l'API

Voila comment on verifie si un user a le droit ou non de réaliser une action 
Prérequis le username de la personne qui tente de réalise l'action et l'action qu'il tente de réalisé 

in appelle la fonction ci dessous qui va recup les different id des groupe auquelle appartient le lanceur de l'action et verifier si l'action est bien une action valide

```go
package permission

import (
	"DUCKY/serveur/database"
	"DUCKY/serveur/logs"
	"fmt"
)

func PrePermissionCheck(username, action string) ([]int, string, error) {
	// Placeholder for future pre-permission checks
	acUserID, err := database.Get_User_ID_By_Username(database.GetDatabase(), username)
	if err != nil {
		logs.Write_Log("ERROR", fmt.Sprintf("Erreur lors de la récupération de l'ID utilisateur pour %s : %v", username, err))
		return nil, "", fmt.Errorf("Erreur lors de la récupération de l'ID utilisateur.")
	}
	Domain_list, err := database.GetDomainsForUser(database.DB, acUserID)
	logs.Write_Log("DEBUG", fmt.Sprintf("Domaines pour l'utilisateur %s (ID %d) : %v", username, acUserID, Domain_list))
	action, CheckPermission := IsValidAction(action)
	if !CheckPermission {
		return nil, "", fmt.Errorf("Action non valide, contactez l'éditeur.")
	}
	groupsID, err := database.GetGroupIDsFromDomains(database.DB, Domain_list)
	if err != nil {
		logs.Write_Log("ERROR", fmt.Sprintf("Erreur lors de la récupération des groupes de l'utilisateur %s : %v", username, err))
		return nil, "", fmt.Errorf("Erreur lors de la récupération des groupes de l'utilisateur.")
	}

	return groupsID, action, nil
}


package permission

import "strings"

// Liste des actions possibles (colonnes de la table user_permission_test)
var validActions = []string{
	"none",
	"web_admin",
	"auth",
	"compare",
	"search",
	"can_read",
	"can_write",
	"api_read_permission",
	"api_write_permission",
}

// IsValidAction vérifie si une action est valide
func IsValidAction(action string) (string, bool) {
	action = strings.ToLower(action) // pour éviter les problèmes de casse
	for _, a := range validActions {
		if a == action {
			return a, true
		}
	}
	return action, false
}
```

ensuite on appelle la deuxieme fonction qui va necesité le domain qui est impacté par l'action du l'utilisateur cette fonction va verifier si le user a le driot de réalisé l'action dans le domaine demandé

	ok, msg := permission.CheckPermissionsMultipleDomains(groupIDs, action, []string{"*"})
	if !ok {
		logs.Write_Log("WARNING", fmt.Sprintf("Permission refusée pour %s : %s", sender, msg))
		return "Permission refusée : " + msg
	}

j'ai oublier de précisé que pour tous ceux qui est log nous utilison une fonction 

logs.Write_Log("WARNING", fmt.Sprintf("Permission refusée pour %s : %s", sender, msg))


voila mtn tu a la logique pour gère les permission dans mon AD on va donc l'intégré ensemble 